var Utils = (function() {
    return {
        getBarData: function(data) {
            var items = data.children;
            var result = {
                    labels: [],
                    series: []
                },
                values = [];

            items.forEach(function(item) {
                result.labels.push(item.name);
                values.push(item.children.length);
            })

            result.series.push({
                label: 'Projects count',
                values: values
            })

            return result;
        }
    }
}())
var Search = (function() {
    var url = '',
        apiUrl,
        inputTxt,
        searchBtn,
        listeners = [],
        query = {
            q: 'onebitxy',
            sort: "forks",
            order: "desc",
            per_page: 100
        };

    return {
        init: function(url) {
            apiUrl = url;

            searchBtn = d3.select('#search-btn');
            inputTxt = d3.select('#search-input');
            searchBtn.on('click', function() {
                var qStr = inputTxt.property('value');
                var requestUrl = parseSearchUrl(qStr);
                console.log(requestUrl);
                listeners.forEach(function(listener) {
                    try {
                        listener(requestUrl);
                    } catch (error) {
                        console.log(error);
                    }
                })
            })
        },

        addListener: function(listener) {
            listeners.push(listener);
        }
    };

    function parseSearchUrl(qStr) {
        query.q = qStr || 'onebitxy';
        
        var arr = [];
        for (var key in query) {
            arr.push(key + '=' + query[key]);
        };

        return apiUrl + '?' + arr.join('&');
    }
}())
var Bar = (function() {
    var chartWidth = 300,
        barHeight = 20,
        groupHeight = 0,
        gapBetweenGroups = 10,
        spaceForLabels = 150,
        spaceForLegend = 150,
        svg,
        data,
        yAxis;

    // Zip the series data together (first values, second values, etc.)
    var zippedData = [];

    return {
        init: function(title, barId) {
            d3.select("#barTitle").text(title);
            chart = d3.select(barId)
                      .append("svg")
                      .attr("class", "chart");
        },

        show: function(data) {
            showBar(data);
        }
    }

    function zippingData(data) {
        for (var i = 0; i < data.labels.length; i++) {
            for (var j = 0; j < data.series.length; j++) {
                zippedData.push(data.series[j].values[i]);
            }
        }
    }

    function showBar(data) {
        data = data || {};      
        zippedData = []; //Clean
        groupHeight = barHeight * data.series.length;
        zippingData(data);

        // Color scale
        // var color = d3.schemeCategory20();
        var color = d3.scaleOrdinal(d3.schemeCategory20);
        var chartHeight = barHeight * zippedData.length + gapBetweenGroups * data.labels.length;

        var x = d3.scaleLinear()
            .domain([0, d3.max(zippedData)])
            .range([0, chartWidth]);

        var y = d3.scaleLinear()
            .range([chartHeight + gapBetweenGroups, 0]);


        yAxis = d3.axisLeft(y)
                  .tickFormat('')
                  .tickSize(0);

        var svg = chart
            .attr("width", spaceForLabels + chartWidth + spaceForLegend)
            .attr("height", chartHeight);

        // Get the nodes
        var barNodes = svg.selectAll("g").data(zippedData, function (d, i) {
            return [d, i];
        })

        // Create bars
        var bar = barNodes
            .enter()
            .append("g")
            .attr("transform", function(d, i) {
                return "translate(" + spaceForLabels + "," + (i * barHeight + gapBetweenGroups * (0.5 + Math.floor(i / data.series.length))) + ")";
            });

        // Create rectangles of the correct width
        bar.append("rect")
            .attr("fill", function(d, i) {
                return color(i % data.series.length);
            })
            .attr("class", "bar")
            .attr("width", x)
            .attr("height", barHeight - 1);

        // Add text label in bar
        bar.append("text")
            .attr("x", function(d) {
                return x(d) - 3;
            })
            .attr("y", barHeight / 2)
            .attr("fill", "red")
            .attr("dy", ".35em")
            .text(function(d) {
                return d;
            });

        // Draw labels
        bar.append("text")
            .attr("class", "label")
            .attr("x", function(d) {
                return -10;
            })
            .attr("y", groupHeight / 2)
            .attr("dy", ".35em")
            .text(function(d, i) {
                if (i % data.series.length === 0)
                    return data.labels[Math.floor(i / data.series.length)];
                else
                    return ""
            });

        // Delete the extra nodes
        barNodes.exit()
            .transition()
            // .style({
            //     opacity: 0
            // })
            .remove();

        svg.append("g")
            .attr("class", "y axis")
            .attr("transform", "translate(" + spaceForLabels + ", " + -gapBetweenGroups / 2 + ")")
            .call(yAxis);

        // Draw legend
        var legendRectSize = 18,
            legendSpacing = 4;

        var legendData = svg.selectAll('.legend')
            .data(data.series);

        var legend = legendData
            .enter()
            .append('g')
            .attr('transform', function(d, i) {
                var height = legendRectSize + legendSpacing;
                var offset = -gapBetweenGroups / 2;
                var horz = spaceForLabels + chartWidth + 40 - legendRectSize;
                var vert = i * height - offset;
                return 'translate(' + horz + ',' + vert + ')';
            });

        legend.append('rect')
            .attr('width', legendRectSize)
            .attr('height', legendRectSize)
            .style('fill', function(d, i) {
                return color(i);
            })
            .style('stroke', function(d, i) {
                return color(i);
            });

        legend.append('text')
            .attr('class', 'legend')
            .attr('x', legendRectSize + legendSpacing)
            .attr('y', legendRectSize - legendSpacing)
            .text(function(d) {
                return d.label;
            });

        legendData.exit().remove();
    }
}())
(function() {
    const SEARCH_API = 'http://127.0.0.1:8081/api/repo/search';
    var loading = document.getElementById("onesadl");

    Search.init(SEARCH_API);

    Bar.init("TOP DEV LANGUAGES", "#barId");


    function show(url) {
        url = url || SEARCH_API;

        var loader = setTimeout(function() {
            loading.style.display = "block";
        }, 300);

        d3.json(url, function(err, result) {
            if (err) {
                clearTimeout(loader);
                loading.style.display = "none";
                alert("LOAD ERROR! CHECK NETWORK...")
            };

            const data = result.data;
            Bar.show(Utils.getBarData(data));

            clearTimeout(loader);
            loading.style.display = "none";
        });
    }

    Search.addListener(function(url) {
        show(url);
    })

    show();
})()
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcG8vdXRpbC5qcyIsInJlcG8vc2VhcmNoLmpzIiwicmVwby9iYXIuanMiLCJyZXBvL21haW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6InNhZGwubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIFV0aWxzID0gKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldEJhckRhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IGRhdGEuY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IFtdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBbXTtcblxuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmxhYmVscy5wdXNoKGl0ZW0ubmFtZSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goaXRlbS5jaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgcmVzdWx0LnNlcmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsYWJlbDogJ1Byb2plY3RzIGNvdW50JyxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHZhbHVlc1xuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbn0oKSkiLCJ2YXIgU2VhcmNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB1cmwgPSAnJyxcbiAgICAgICAgYXBpVXJsLFxuICAgICAgICBpbnB1dFR4dCxcbiAgICAgICAgc2VhcmNoQnRuLFxuICAgICAgICBsaXN0ZW5lcnMgPSBbXSxcbiAgICAgICAgcXVlcnkgPSB7XG4gICAgICAgICAgICBxOiAnb25lYml0eHknLFxuICAgICAgICAgICAgc29ydDogXCJmb3Jrc1wiLFxuICAgICAgICAgICAgb3JkZXI6IFwiZGVzY1wiLFxuICAgICAgICAgICAgcGVyX3BhZ2U6IDEwMFxuICAgICAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICBhcGlVcmwgPSB1cmw7XG5cbiAgICAgICAgICAgIHNlYXJjaEJ0biA9IGQzLnNlbGVjdCgnI3NlYXJjaC1idG4nKTtcbiAgICAgICAgICAgIGlucHV0VHh0ID0gZDMuc2VsZWN0KCcjc2VhcmNoLWlucHV0Jyk7XG4gICAgICAgICAgICBzZWFyY2hCdG4ub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHFTdHIgPSBpbnB1dFR4dC5wcm9wZXJ0eSgndmFsdWUnKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdFVybCA9IHBhcnNlU2VhcmNoVXJsKHFTdHIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlcXVlc3RVcmwpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcihyZXF1ZXN0VXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZExpc3RlbmVyOiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlU2VhcmNoVXJsKHFTdHIpIHtcbiAgICAgICAgcXVlcnkucSA9IHFTdHIgfHwgJ29uZWJpdHh5JztcbiAgICAgICAgXG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHF1ZXJ5KSB7XG4gICAgICAgICAgICBhcnIucHVzaChrZXkgKyAnPScgKyBxdWVyeVtrZXldKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYXBpVXJsICsgJz8nICsgYXJyLmpvaW4oJyYnKTtcbiAgICB9XG59KCkpIiwidmFyIEJhciA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgY2hhcnRXaWR0aCA9IDMwMCxcbiAgICAgICAgYmFySGVpZ2h0ID0gMjAsXG4gICAgICAgIGdyb3VwSGVpZ2h0ID0gMCxcbiAgICAgICAgZ2FwQmV0d2Vlbkdyb3VwcyA9IDEwLFxuICAgICAgICBzcGFjZUZvckxhYmVscyA9IDE1MCxcbiAgICAgICAgc3BhY2VGb3JMZWdlbmQgPSAxNTAsXG4gICAgICAgIHN2ZyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgeUF4aXM7XG5cbiAgICAvLyBaaXAgdGhlIHNlcmllcyBkYXRhIHRvZ2V0aGVyIChmaXJzdCB2YWx1ZXMsIHNlY29uZCB2YWx1ZXMsIGV0Yy4pXG4gICAgdmFyIHppcHBlZERhdGEgPSBbXTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKHRpdGxlLCBiYXJJZCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI2JhclRpdGxlXCIpLnRleHQodGl0bGUpO1xuICAgICAgICAgICAgY2hhcnQgPSBkMy5zZWxlY3QoYmFySWQpXG4gICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaGFydFwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaG93OiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBzaG93QmFyKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemlwcGluZ0RhdGEoZGF0YSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGEuc2VyaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgemlwcGVkRGF0YS5wdXNoKGRhdGEuc2VyaWVzW2pdLnZhbHVlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG93QmFyKGRhdGEpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwge307ICAgICAgXG4gICAgICAgIHppcHBlZERhdGEgPSBbXTsgLy9DbGVhblxuICAgICAgICBncm91cEhlaWdodCA9IGJhckhlaWdodCAqIGRhdGEuc2VyaWVzLmxlbmd0aDtcbiAgICAgICAgemlwcGluZ0RhdGEoZGF0YSk7XG5cbiAgICAgICAgLy8gQ29sb3Igc2NhbGVcbiAgICAgICAgLy8gdmFyIGNvbG9yID0gZDMuc2NoZW1lQ2F0ZWdvcnkyMCgpO1xuICAgICAgICB2YXIgY29sb3IgPSBkMy5zY2FsZU9yZGluYWwoZDMuc2NoZW1lQ2F0ZWdvcnkyMCk7XG4gICAgICAgIHZhciBjaGFydEhlaWdodCA9IGJhckhlaWdodCAqIHppcHBlZERhdGEubGVuZ3RoICsgZ2FwQmV0d2Vlbkdyb3VwcyAqIGRhdGEubGFiZWxzLmxlbmd0aDtcblxuICAgICAgICB2YXIgeCA9IGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oWzAsIGQzLm1heCh6aXBwZWREYXRhKV0pXG4gICAgICAgICAgICAucmFuZ2UoWzAsIGNoYXJ0V2lkdGhdKTtcblxuICAgICAgICB2YXIgeSA9IGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgIC5yYW5nZShbY2hhcnRIZWlnaHQgKyBnYXBCZXR3ZWVuR3JvdXBzLCAwXSk7XG5cblxuICAgICAgICB5QXhpcyA9IGQzLmF4aXNMZWZ0KHkpXG4gICAgICAgICAgICAgICAgICAudGlja0Zvcm1hdCgnJylcbiAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgwKTtcblxuICAgICAgICB2YXIgc3ZnID0gY2hhcnRcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgc3BhY2VGb3JMYWJlbHMgKyBjaGFydFdpZHRoICsgc3BhY2VGb3JMZWdlbmQpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBjaGFydEhlaWdodCk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBub2Rlc1xuICAgICAgICB2YXIgYmFyTm9kZXMgPSBzdmcuc2VsZWN0QWxsKFwiZ1wiKS5kYXRhKHppcHBlZERhdGEsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2QsIGldO1xuICAgICAgICB9KVxuXG4gICAgICAgIC8vIENyZWF0ZSBiYXJzXG4gICAgICAgIHZhciBiYXIgPSBiYXJOb2Rlc1xuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgc3BhY2VGb3JMYWJlbHMgKyBcIixcIiArIChpICogYmFySGVpZ2h0ICsgZ2FwQmV0d2Vlbkdyb3VwcyAqICgwLjUgKyBNYXRoLmZsb29yKGkgLyBkYXRhLnNlcmllcy5sZW5ndGgpKSkgKyBcIilcIjtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSByZWN0YW5nbGVzIG9mIHRoZSBjb3JyZWN0IHdpZHRoXG4gICAgICAgIGJhci5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcihpICUgZGF0YS5zZXJpZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYmFyXCIpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHgpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBiYXJIZWlnaHQgLSAxKTtcblxuICAgICAgICAvLyBBZGQgdGV4dCBsYWJlbCBpbiBiYXJcbiAgICAgICAgYmFyLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgoZCkgLSAzO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBiYXJIZWlnaHQgLyAyKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwicmVkXCIpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiLjM1ZW1cIilcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIERyYXcgbGFiZWxzXG4gICAgICAgIGJhci5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWxcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xMDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgZ3JvdXBIZWlnaHQgLyAyKVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi4zNWVtXCIpXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgJSBkYXRhLnNlcmllcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVsc1tNYXRoLmZsb29yKGkgLyBkYXRhLnNlcmllcy5sZW5ndGgpXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBEZWxldGUgdGhlIGV4dHJhIG5vZGVzXG4gICAgICAgIGJhck5vZGVzLmV4aXQoKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLy8gLnN0eWxlKHtcbiAgICAgICAgICAgIC8vICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAvLyB9KVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieSBheGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHNwYWNlRm9yTGFiZWxzICsgXCIsIFwiICsgLWdhcEJldHdlZW5Hcm91cHMgLyAyICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG5cbiAgICAgICAgLy8gRHJhdyBsZWdlbmRcbiAgICAgICAgdmFyIGxlZ2VuZFJlY3RTaXplID0gMTgsXG4gICAgICAgICAgICBsZWdlbmRTcGFjaW5nID0gNDtcblxuICAgICAgICB2YXIgbGVnZW5kRGF0YSA9IHN2Zy5zZWxlY3RBbGwoJy5sZWdlbmQnKVxuICAgICAgICAgICAgLmRhdGEoZGF0YS5zZXJpZXMpO1xuXG4gICAgICAgIHZhciBsZWdlbmQgPSBsZWdlbmREYXRhXG4gICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBsZWdlbmRSZWN0U2l6ZSArIGxlZ2VuZFNwYWNpbmc7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IC1nYXBCZXR3ZWVuR3JvdXBzIC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgaG9yeiA9IHNwYWNlRm9yTGFiZWxzICsgY2hhcnRXaWR0aCArIDQwIC0gbGVnZW5kUmVjdFNpemU7XG4gICAgICAgICAgICAgICAgdmFyIHZlcnQgPSBpICogaGVpZ2h0IC0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBob3J6ICsgJywnICsgdmVydCArICcpJztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGxlZ2VuZC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgbGVnZW5kUmVjdFNpemUpXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgbGVnZW5kUmVjdFNpemUpXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yKGkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcihpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGxlZ2VuZC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xlZ2VuZCcpXG4gICAgICAgICAgICAuYXR0cigneCcsIGxlZ2VuZFJlY3RTaXplICsgbGVnZW5kU3BhY2luZylcbiAgICAgICAgICAgIC5hdHRyKCd5JywgbGVnZW5kUmVjdFNpemUgLSBsZWdlbmRTcGFjaW5nKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmxhYmVsO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbGVnZW5kRGF0YS5leGl0KCkucmVtb3ZlKCk7XG4gICAgfVxufSgpKSIsIihmdW5jdGlvbigpIHtcbiAgICBjb25zdCBTRUFSQ0hfQVBJID0gJ2h0dHA6Ly8xMjcuMC4wLjE6ODA4MS9hcGkvcmVwby9zZWFyY2gnO1xuICAgIHZhciBsb2FkaW5nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvbmVzYWRsXCIpO1xuXG4gICAgU2VhcmNoLmluaXQoU0VBUkNIX0FQSSk7XG5cbiAgICBCYXIuaW5pdChcIlRPUCBERVYgTEFOR1VBR0VTXCIsIFwiI2JhcklkXCIpO1xuXG5cbiAgICBmdW5jdGlvbiBzaG93KHVybCkge1xuICAgICAgICB1cmwgPSB1cmwgfHwgU0VBUkNIX0FQSTtcblxuICAgICAgICB2YXIgbG9hZGVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxvYWRpbmcuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgfSwgMzAwKTtcblxuICAgICAgICBkMy5qc29uKHVybCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQobG9hZGVyKTtcbiAgICAgICAgICAgICAgICBsb2FkaW5nLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICBhbGVydChcIkxPQUQgRVJST1IhIENIRUNLIE5FVFdPUksuLi5cIilcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSByZXN1bHQuZGF0YTtcbiAgICAgICAgICAgIEJhci5zaG93KFV0aWxzLmdldEJhckRhdGEoZGF0YSkpO1xuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobG9hZGVyKTtcbiAgICAgICAgICAgIGxvYWRpbmcuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBTZWFyY2guYWRkTGlzdGVuZXIoZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIHNob3codXJsKTtcbiAgICB9KVxuXG4gICAgc2hvdygpO1xufSkoKSJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
